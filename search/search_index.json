{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Our mission","text":"<p>     The modern economy is built on complex digital systems like the cloud.     They are powerful, but painfully hard to operate.     AI agents promise automation, yet today they fail because they lack     operational intelligence:     an understanding of how engineered digital systems respond to actions.   </p> <p>     A simple truth:     the digital world has no physics,     but it obeys rules humans wrote down, which gives it meaning.     APIs, documentation, and traces precisely define how digital systems behave\u2014     what actions mean, what is allowed, and how failures arise.     The cloud is one such world, encoded by tens of thousands of APIs.   </p> <p> Our mission is to synthesize world models for digital systems using AI\u2014     and use them as training grounds to improve AI\u2019s execution intelligence,     starting with the cloud.   </p> <p>     \u2014 The Vera Team   </p>"},{"location":"vera-aws/","title":"Vera AWS (Version 0.1)","text":"<p>Local AWS EC2 emulator. Currently supports 89 resource types \u2014 VPCs, instances, security groups, volumes, and more (complete list at the end). Runs on your machine with no AWS account needed.</p>"},{"location":"vera-aws/#setup","title":"Setup","text":"<pre><code>./install.sh\n</code></pre> <p>This creates a venv, installs dependencies, sets up dummy AWS credentials (<code>~/.aws/credentials</code>), and generates two wrapper scripts in <code>.bin/</code>:</p> <ul> <li><code>awscli</code> \u2014 drop-in for <code>aws</code>, routes requests to the emulator</li> <li><code>terlocal</code> \u2014 drop-in for <code>terraform</code>, configures the AWS provider endpoint</li> </ul>"},{"location":"vera-aws/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>AWS CLI and Terraform are installed automatically by <code>install.sh</code> if missing (macOS/Linux)</li> </ul>"},{"location":"vera-aws/#usage","title":"Usage","text":"<p>Start the emulator on one terminal:</p> <pre><code>uv run main.py\n# Running at http://localhost:5003\n</code></pre>"},{"location":"vera-aws/#aws-cli-via-uv-run-awscli","title":"AWS CLI via <code>uv run awscli</code>","text":"<pre><code>uv run awscli ec2 create-vpc --cidr-block 10.0.0.0/16\n# {\n#     \"Vpc\": {\n#         \"VpcId\": \"vpc-28bc3a23\",\n#         \"CidrBlock\": \"10.0.0.0/16\",\n#         \"State\": \"available\",\n#         ...\n#     }\n# }\n</code></pre>"},{"location":"vera-aws/#aws-cli-directly-via-awscli","title":"AWS CLI directly via <code>awscli</code>","text":"<p>Simply activate the venv and run <code>awscli</code>:</p> <pre><code>source .venv/bin/activate\n\nawscli ec2 describe-vpcs\nawscli ec2 run-instances --image-id ami-12345678 --instance-type t2.micro\nawscli ec2 describe-instances\n</code></pre>"},{"location":"vera-aws/#terraform","title":"Terraform","text":"<p>Write standard Terraform \u2014 no provider overrides needed:</p> <pre><code>provider \"aws\" {\n  region = \"us-east-1\"\n}\n\nresource \"aws_vpc\" \"main\" {\n  cidr_block = \"10.0.0.0/16\"\n}\n</code></pre> <p>Then use <code>uv run terlocal</code> instead of <code>terraform</code>. Or simply activate the venv and directly run <code>terlocal</code>:</p> <pre><code>source .venv/bin/activate\n\nterlocal init\nterlocal apply -auto-approve\nterlocal destroy -auto-approve\n</code></pre> <p>See <code>tests/tf/</code> for more examples.</p>"},{"location":"vera-aws/#running-tests","title":"Running Tests","text":"<pre><code># Terminal 1 \u2014 start the emulator\nuv run main.py\n\n# Terminal 2 \u2014 run 260 CLI commands against it\ncd tests\nuv run eval_emulator.py test.sh --endpoint http://localhost:5003 \\\n  --checkpoint eval_results.json --start-from 0\nuv run analyze_results.py eval_results.json\n\n# Terraform smoke test\ncd tests/tf/00-simple-vpc\nuv run terlocal init &amp;&amp; uv run terlocal apply -auto-approve\n</code></pre> Emulator Passing (260 commands) LocalStack 122 (47%) Vera AWS 187 (72%)"},{"location":"vera-aws/#project-structure","title":"Project Structure","text":"<pre><code>main.py                        Flask server (port 5003)\ninstall.sh                     Sets up awscli/terlocal wrappers\nemulator_core/\n\u251c\u2500\u2500 state.py                   In-memory resource store\n\u251c\u2500\u2500 backend.py                 Base backend class\n\u251c\u2500\u2500 gateway/base.py            Action \u2192 backend dispatch\n\u2514\u2500\u2500 services/                  89 resource modules\ntests/\n\u251c\u2500\u2500 test.sh                    260 CLI commands (awscli wrapper)\n\u251c\u2500\u2500 eval_emulator.py           Evaluator with checkpointing\n\u2514\u2500\u2500 tf/                        Terraform test cases\n</code></pre>"},{"location":"vera-aws/#supported-resources","title":"Supported Resources","text":"<p>Vera AWS supports the following resources (via EC2 API):</p> <ul> <li>Account Attributes</li> <li>AFIs</li> <li>AMIs</li> <li>Authorization Rules</li> <li>AWS Marketplace</li> <li>Block Public Access</li> <li>Bundle Tasks</li> <li>BYOASN</li> <li>BYOIP</li> <li>Capacity Reservations</li> <li>Carrier Gateways</li> <li>Certificate Revocation Lists</li> <li>Client Connections</li> <li>Client VPN Endpoints</li> <li>Configuration Files</li> <li>Customer Gateways</li> <li>Customer Owned IP Addresses</li> <li>Declarative Policies (Account Status Report)</li> <li>Dedicated Hosts</li> <li>DHCP Options</li> <li>EC2 Fleet</li> <li>EC2 Instance Connect Endpoints</li> <li>EC2 Topology</li> <li>Elastic Graphics</li> <li>Elastic IP Addresses</li> <li>Elastic Network Interfaces</li> <li>Encryption</li> <li>Event Notifications</li> <li>Event Windows For Scheduled Events</li> <li>Fast Snapshot Restores</li> <li>Infrastructure Performance</li> <li>Instance Types</li> <li>Instances</li> <li>Internet Gateways</li> <li>IPAMs</li> <li>Key Pairs</li> <li>Launch Templates</li> <li>Link Aggregation Groups</li> <li>Local Gateways</li> <li>Managed Prefix Lists</li> <li>NAT Gateways</li> <li>Network Access Analyzer</li> <li>Network ACLs</li> <li>Nitro TPM</li> <li>Placement Groups</li> <li>Pools</li> <li>Reachability Analyzer</li> <li>Regions And Zones</li> <li>Reserved Instances</li> <li>Resource Discoveries</li> <li>Resource IDs</li> <li>Route Servers</li> <li>Route Tables</li> <li>Routes</li> <li>Scheduled Instances</li> <li>Scopes</li> <li>Security Groups</li> <li>Serial Console</li> <li>Service Links</li> <li>Snapshots</li> <li>Spot Fleet</li> <li>Spot Instances</li> <li>Subnets</li> <li>Tags</li> <li>Target Networks</li> <li>Traffic Mirroring</li> <li>Transit Gateway Connect</li> <li>Transit Gateway Multicast</li> <li>Transit Gateway Peering Attachments</li> <li>Transit Gateway Policy Tables</li> <li>Transit Gateway Route Tables</li> <li>Transit Gateways</li> <li>Verified Access Endpoints</li> <li>Verified Access Groups</li> <li>Verified Access Instances</li> <li>Verified Access Logs</li> <li>Verified Access Trust Providers</li> <li>Virtual Private Gateway Routes</li> <li>Virtual Private Gateways</li> <li>VM Export</li> <li>VM Import</li> <li>Volumes</li> <li>VPC Endpoint Services</li> <li>VPC Endpoints</li> <li>VPC Flow Logs</li> <li>VPC Peering</li> <li>VPCs</li> <li>VPN Concentrators</li> <li>VPN Connections</li> </ul>"},{"location":"blogs/cloudagent/cloudagent/","title":"The quest for AI Agents as DevOps.","text":"February 6, 2026  <p>Cloud infrastructure is the backbone of the modern IT industry, yet managing it remains surprisingly manual and fragile. From provisioning resources to debugging failures and monitoring runtime health, DevOps engineers constantly wrestle with complexity, partial observability, and high-stakes errors.</p> <p>In our recent paper, \u201cCloud Infrastructure Management in the Age of AI Agents,\u201d we set out to understand whether large language model (LLM)\u2013based agents can meaningfully automate real cloud management tasks \u2014 and where they fall short. </p> <p>We deliberately stress-tested current agents against real cloud interfaces. Our goal was not to show that agents can succeed in idealized settings, but to expose the fundamental friction between LLMs and cloud management modalities. The result: agents are promising, but today\u2019s cloud interfaces were never designed for them.</p>"},{"location":"blogs/cloudagent/cloudagent/#the-setup-four-agents-four-modalities","title":"The Setup: Four Agents, Four Modalities","text":"<p>To test the current capabilities of AI, we conducted a preliminary study using four different \"modalities\"\u2014the standard interfaces humans use to manage the cloud. We built four distinct AI agent prototypes to perform tasks on Microsoft Azure:</p> <ol> <li>SDK Agent: Uses Python code (imperative programming).</li> <li>CLI Agent: Uses command-line shell scripts (terminal-based).</li> <li>Infrastructure-as-Code (IaC) Agent: Uses Terraform (declarative configuration).</li> <li>Web Agent: Navigates the web portal visually (just like a human clicking buttons in the web console).</li> </ol> <p> Figure 1: Four cloud user interaction modalities with simplified code snippets. </p>"},{"location":"blogs/cloudagent/cloudagent/#insight-1-speed-comes-at-the-cost-of-awareness","title":"Insight 1: Speed Comes at the Cost of Awareness","text":"<p>The CLI agent dominated in efficiency, completing many tasks in a single step (1.6 steps on average). Generating one command was often enough to spin up resources that would require dozens of UI interactions in the web portal. In contrast, the Web agent was painfully slow \u2014 sometimes taking over 30\u00d7 more steps due to page loads, menu navigation, and confirmation dialogs.</p> <p>But this speed advantage collapsed during update tasks.</p> <p>Updating existing infrastructure requires understanding the current cloud state. Here, the CLI and SDK agents struggled. They frequently failed because they issued update commands without first querying existing configurations \u2014 or misinterpreted partial state returned by APIs. Each additional \u201cstate-query\u201d step introduced new failure modes.</p> <p>The Web agent, surprisingly, performed better on updates (67% success rate versus 33% for IaC). The reason was simple but revealing: the UI shows the state explicitly. Disk attachments, VM settings, and dependencies were visible on screen, reducing hallucinations and incorrect assumptions.</p>"},{"location":"blogs/cloudagent/cloudagent/#observation-1-blindness-to-state","title":"Observation 1: Blindness to State","text":"<p>Coding agents are fast because they tend to skip state inspection \u2014 but that same blindness becomes a liability once tasks require modifying existing infrastructure.</p> <p>This exposes a core tension: LLMs are good at issuing actions, but cloud updates are fundamentally state-dependent.</p>"},{"location":"blogs/cloudagent/cloudagent/#insight-2-declarative-tools-arent-always-the-right-tool","title":"Insight 2: Declarative Tools Aren\u2019t Always the Right Tool","text":"<p>Infrastructure-as-Code (IaC) is widely regarded as best practice for human DevOps teams. It abstracts away execution details and provides strong guarantees for large-scale changes.</p> <p>But when we evaluated agents on monitoring tasks, IaC performed the worst \u2014 with only a 40% success rate.</p> <p>Why?</p> <p>IaC tools are designed to define desired state, not to query runtime telemetry. When asked to check system health or retrieve live information, the IaC agent frequently hallucinated unsupported commands or misused Terraform constructs to approximate monitoring functionality.</p> <p>Meanwhile, the Web agent excelled. Azure\u2019s dashboards already aggregate metrics, logs, and health signals into visual summaries. The agent could simply \u201clook\u201d at graphs that don\u2019t exist in SDK or CLI form \u2014 and that IaC cannot express at all.</p>"},{"location":"blogs/cloudagent/cloudagent/#observation-2-misalignment-of-tools-and-needs","title":"Observation 2: Misalignment of Tools and Needs","text":"<p>A tool that is ideal for humans in one phase of the cloud infrastructure lifecycle can be fundamentally misaligned with an agent\u2019s needs in another.</p> <p>This is not an implementation bug \u2014 it\u2019s a design mismatch.</p>"},{"location":"blogs/cloudagent/cloudagent/#insight-3-insight-3-observability-shapes-agent-reliability","title":"Insight 3: Insight 3: Observability Shapes Agent Reliability","text":"<p>Across all tasks, one factor consistently predicted agent success: how clearly the modality exposed system state and errors.</p> <p> Figure 2: The radar chart summarizing agent performance across different modalities. </p> <ul> <li>SDK and CLI agents benefited from precise error messages and return codes, which sometimes allowed recovery after failure.</li> <li>Web agents, while slower, benefited from rich observability \u2014 visual structure, dashboards, and pre-validated UI flows.</li> <li>IaC agents struggled whenever context windows truncated state, or when runtime information fell outside declarative abstractions.</li> </ul>"},{"location":"blogs/cloudagent/cloudagent/#observation-3-agent-reliability-is-dependent-on-observability","title":"Observation 3: Agent Reliability is Dependent on Observability","text":"<p>Agent failures are often not due to reasoning errors, but due to missing or poorly surfaced state.</p> <p>This suggests that improving agents alone is insufficient \u2014 the interfaces themselves must become more agent-aware.</p>"},{"location":"blogs/cloudagent/cloudagent/#the-path-forward-rethinking-cloud-management-for-agents","title":"The Path Forward: Rethinking Cloud Management for Agents","text":"<p>Our experiments point to a clear conclusion: simply wiring an LLM to a cloud shell is not enough. Effective agentic cloud management requires architectural changes, not just better prompts.</p> <p> Figure 3: Envisioned agentic system architecture and workflow. </p> <p>We outline a roadmap with three key pillars:</p>"},{"location":"blogs/cloudagent/cloudagent/#1-multi-agent-modality-aware-orchestration","title":"1. Multi-Agent, Modality-Aware Orchestration","text":"<p>No single interface is universally optimal. Fast provisioning favors CLI; large-scale updates favor IaC; debugging and monitoring favor UI-level visibility.</p> <p>Future systems should route tasks to specialized agents, rather than forcing one agent to master everything.</p>"},{"location":"blogs/cloudagent/cloudagent/#2-sandboxed-exploration-cloud-gyms","title":"2. Sandboxed Exploration (\u201cCloud Gyms\u201d)","text":"<p>Cloud actions are slow, costly, and irreversible. Trial-and-error in production is unacceptable.</p> <p>Agents need safe and low-cost environments to learn and explore strategies, validate workflows, and fail cheaply before touching real infrastructure.</p>"},{"location":"blogs/cloudagent/cloudagent/#3-workflow-memory-and-guardrails","title":"3. Workflow Memory and Guardrails","text":"<p>Once an agent figures out how to perform a complex task, it shouldn\u2019t start from scratch next time.</p> <p>Validated workflows should be cached, reused, and guarded by explicit human-in-the-loop checks \u2014 especially for destructive or high-impact operations.</p>"},{"location":"blogs/cloudagent/cloudagent/#closing-thoughts","title":"Closing Thoughts","text":"<p>Cloud infrastructure management is ripe for automation \u2014 but our study shows that the interface matters as much as the model.</p> <p>By combining the speed of CLI, the scalability of IaC, and the observability of ClickOps \u2014 and by designing agents that can reason across these modalities \u2014 we can move toward a new class of autonomous cloud engineers that are not only capable, but trustworthy.</p> <p>If you\u2019re building AI agents for real systems, this is the uncomfortable takeaway: today\u2019s tools were built for humans, not agents \u2014 and agents expose their cracks.</p> <p>For more details, check out our full paper in the ACM SIGOPS Operating Systems Review.</p> Authors:     Zhenning Yang, Archit Bhatnagar, Yiming Qiu, Tongyuan Miao, Patrick Tser Jern Kon, Yunming Xiao, Yibo Huang, Martin Casado, Ang Chen    Affiliations:     University of Michigan, UC Berkeley, Andreessen Horowitz    Paper link:        https://dl.acm.org/doi/abs/10.1145/3759441.3759443      BibTeX: <pre>\n<code>@article{yang2025cloudagent,\n    author = {Yang, Zhenning and Bhatnagar, Archit and Qiu, Yiming and Miao, Tongyuan and Tser Jern Kon, Patrick and Xiao, Yunming and Huang, Yibo and Casado, Martin and Chen, Ang},\n    title = {Cloud Infrastructure Management in the Age of AI Agents},\n    journal = {SIGOPS Oper. Syst. Rev.},\n    year = {2025}\n}</code></pre>"},{"location":"blogs/cloudemu/cloudemu/","title":"No More Manual Mocks: A Case for Learned Cloud Emulators","text":"February 6, 2026  <p>DevOps engineers face a constant dilemma: testing against the real cloud is expensive and slow, but testing locally requires emulators that often lack features or behave differently than the real thing.</p> <p>Existing emulators (like the popular LocalStack) rely on manual engineering. We observe that this is a Sisyphean task\u2014AWS alone has over 240 services, and human developers struggle to keep up with the constant stream of new APIs and updates. As a result, coverage is often spotty; for example, we found that an existing emulator LocalStack covers only ~11% of the AWS Network Firewall APIs.</p> <p>In our paper, we propose a paradigm shift: instead of hand-coding mocks, using Large Language Models (LLMs) to learn the emulation logic directly from cloud documentation.</p>"},{"location":"blogs/cloudemu/cloudemu/#the-learned-emulator-approach","title":"The \"Learned Emulator\" Approach","text":"<p>Simply asking an LLM to \"write a cloud emulator\" results in buggy, hallucinated code. To solve this, we introduce a neuro-symbolic workflow that constrains the AI using formal abstractions. We view each cloud resource not just as code, but as a formal state machine (SM) and the entire cloud as a hierarchical state machine.</p> <p> Figure 1: The grammar for specifying an emulator. </p> <p>Our workflow consists of three key stages:</p> <ol> <li>Documentation Wrangling: We automatically scrape and index massive cloud documentation (like AWS PDFs), organizing it into resource-specific contexts to overcome LLM context window limits.</li> <li>State Machine (SM) Extraction: Instead of generating raw Python code immediately, we task the LLM with extracting a formal State Machine specification from the docs. This captures the resource's states and valid transitions (API calls like <code>CreateVpc</code>), enforcing logic and dependencies that unstructured code generation misses.</li> <li>Automated Alignment: To ensure the emulator behaves exactly like the real cloud, we run traces against both our generated emulator and the actual cloud. We detect discrepancies (e.g., an error code mismatch) and feed them back to the LLM to patch the logic automatically.</li> </ol> <p> Figure 2: Our envisioned workflow. </p>"},{"location":"blogs/cloudemu/cloudemu/#preliminary-results","title":"Preliminary Results","text":"<p>We built a prototype and the results highlight significant advantages over current manual methods:</p> <ul> <li>Better Coverage: In our preliminary tests, we achieved complete coverage for the AWS Network Firewall service, compared to just 11% for the state-of-the-art manual emulator.</li> <li>Accuracy: By modeling resources as State Machines, we prevent common logic errors. As shown below, our SM-based approach maintains high accuracy during state updates, whereas a direct-to-code (D2C) emulator generation using an LLM often fails completely (0% accuracy) because it loses track of resource dependencies.</li> </ul> <p> Figure 3: Accuracy of learned emulators across scenarios. </p> <p>We also used our extracted state machines to quantify the complexity of different cloud services, counting the number of state transitions inherent to services like EC2 versus DynamoDB.</p> <p> Figure 4: CDF of SM complexity across services. </p>"},{"location":"blogs/cloudemu/cloudemu/#the-future-a-cloud-gym","title":"The Future: A \"Cloud Gym\"","text":"<p>Beyond just testing, we believe this technology opens new doors. A high-fidelity, zero-cost emulator could serve as a \"Cloud Gym\", a training ground for AI agents to learn how to manage cloud infrastructure and understand the intricacies, without the risk of racking up a massive bill.</p> <p>By turning static documentation into executable logic, we hope to finally solve the bottleneck of cloud development velocity.</p> <p>For more details, check out our full paper in the HotNets '25 proceedings.</p> Authors:     Archit Bhatnagar, Yiming Qiu, Sarah McClure, Sylvia Ratnasamy, Ang Chen    Affiliations:     University of Michigan, The University of Hong Kong, UC Berkeley    Paper link:        https://dl.acm.org/doi/10.1145/3772356.3772404      BibTeX: <pre>\n<code>@inproceedings{bhatnagar2025cloudemu,\n  author = {Bhatnagar, Archit and Qiu, Yiming and McClure, Sarah and Ratnasamy, Sylvia and Chen, Ang},\n  title = {A Case for Learned Cloud Emulators},\n  booktitle = {Proceedings of the 24th ACM Workshop on Hot Topics in Networks},\n  year = {2025}\n}</code></pre>"},{"location":"pubs/pubs/","title":"Publications","text":"2025            A Case for Learned Cloud Emulators           New            Archit Bhatnagar, Yiming Qiu, Sarah McClure, Sylvia Ratnasamy, Ang           Chen          Proceedings of the 24th ACM Workshop on Hot Topics in Networks,             2025            [paper]          BibTeX <pre>\n@inproceedings{bhatnagar2025cloudemu,\n    author = {Bhatnagar, Archit and Qiu, Yiming and McClure, Sarah and Ratnasamy, Sylvia and Chen, Ang},\n    title = {A Case for Learned Cloud Emulators},\n    booktitle = {Proceedings of the 24th ACM Workshop on Hot Topics in Networks},\n    year = {2025}\n}</pre>            Automated Cloud Infrastructure-as-Code Reconciliation with AI Agents           New            Zhenning Yang, Hui Guan, Victor Nicolet, Brandon Paulsen, Joey Dodds,           Daniel Kroening, Ang Chen          arXiv, 2025            [paper]          BibTeX <pre>\n@misc{yang2025automatedcloudinfrastructureascodereconciliation,\n    title={Automated Cloud Infrastructure-as-Code Reconciliation with AI Agents}, \n    author={Zhenning Yang and Hui Guan and Victor Nicolet and Brandon Paulsen and Joey Dodds and Daniel Kroening and Ang Chen},\n    year={2025},\n    eprint={2510.20211},\n    archivePrefix={arXiv},\n    primaryClass={cs.SE},\n    url={https://arxiv.org/abs/2510.20211}, \n}</pre>            Cloud Infrastructure Management in the Age of AI Agents                     Zhenning Yang, Archit Bhatnagar, Yiming Qiu, Tongyuan Miao, Patrick           Tser Jern Kon, Yunming Xiao, Yibo Huang, Martin Casado, Ang Chen          ACM SIGOPS Operating Systems Review, 2025            [paper]          BibTeX <pre>\n@article{yang2025cloudagent,\n    author = {Yang, Zhenning and Bhatnagar, Archit and Qiu, Yiming and Miao, Tongyuan and Tser Jern Kon, Patrick and Xiao, Yunming and Huang, Yibo and Casado, Martin and Chen, Ang},\n    title = {Cloud Infrastructure Management in the Age of AI Agents},\n    journal = {SIGOPS Oper. Syst. Rev.},\n    year = {2025}\n}</pre>            Automated Bug Discovery in Cloud Infrastructure-as-Code Updates with           LLM Agents                     Yiming Xiang, Zhenning Yang, Jingjia Peng, Hermann Bauer, Patrick Tser           Jern Kon, Yiming Qiu, Ang Chen          IEEE/ACM International Workshop on Cloud Intelligence &amp; AIOps             (AIOps), 2025            [paper]          BibTeX <pre>\n@INPROCEEDINGS{xiang2025automatedbugdiscovery,\n    author={Xiang, Yiming and Yang, Zhenning and Peng, Jingjia and Bauer, Hermann and Kon, Patrick Tser Jern and Qiu, Yiming and Chen, Ang},\n    booktitle={2025 IEEE/ACM International Workshop on Cloud Intelligence &amp; AIOps (AIOps)}, \n    title={Automated Bug Discovery in Cloud Infrastructure-as-Code Updates with LLM Agents}, \n    year={2025}\n}</pre>            Automated Lifting for Cloud Infrastructure-as-Code Programs                     Jingjia Peng, Yiming Qiu, Patrick Tser Jern Kon, Pinhan Zhao, Yibo           Huang, Zheng Guo, Xinyu Wang, Ang Chen          IEEE/ACM International Workshop on Cloud Intelligence &amp; AIOps             (AIOps), 2025            [paper]          BibTeX <pre>\n@INPROCEEDINGS{peng2025automatedlifting,\n    author={Peng, Jingjia and Qiu, Yiming and Kon, Patrick Tser Jern and Zhao, Pinhan and Huang, Yibo and Guo, Zheng and Wang, Xinyu and Chen, Ang},\n    title={Automated Lifting for Cloud Infrastructure-as-Code Programs}, \n    booktitle={2025 IEEE/ACM International Workshop on Cloud Intelligence &amp; AIOps (AIOps)}, \n    year={2025}\n}</pre> 2024            IaC-Eval: A Code Generation Benchmark for Cloud Infrastructure-as-Code           Programs                     Patrick T Kon, Jiachen Liu, Yiming Qiu, Weijun Fan, Ting He, Lei Lin,           Haoran Zhang, Owen M Park, George S Elengikal, Yuxin Kang, Ang Chen,           Mosharaf Chowdhury, Myungjin Lee, Xinyu Wang          Advances in Neural Information Processing Systems, 2024            [paper] [code]           [poster]          BibTeX <pre>\n@inproceedings{NEURIPS2024_f26b2929,\n    author = {Kon, Patrick Tser Jern and Liu, Jiachen and Qiu, Yiming and Fan, Weijun and He, Ting and Lin, Lei and Zhang, Haoran and Park, Owen M. and Elengikal, George S. and Kang, Yuxin and Chen, Ang and Chowdhury, Mosharaf and Lee, Myungjin and Wang, Xinyu},\n    booktitle = {Advances in Neural Information Processing Systems},\n    title = {IaC-Eval: A Code Generation Benchmark for Cloud Infrastructure-as-Code Programs},\n    year = {2024}\n}</pre>            Unearthing semantic checks for cloud infrastructure-as-code programs                     Yiming Qiu, Patrick Tser Jern Kon, Ryan Beckett, Ang Chen          Proceedings of the ACM SIGOPS 30th Symposium on Operating Systems             Principles, 2024            [paper]           [code]          BibTeX <pre>\n@inproceedings{qiu2024unearthingsemanticchecks,\n    author = {Qiu, Yiming and Kon, Patrick Tser Jern and Beckett, Ryan and Chen, Ang},\n    title = {Unearthing Semantic Checks for Cloud Infrastructure-as-Code Programs},\n    year = {2024},\n    booktitle = {Proceedings of the ACM SIGOPS 30th Symposium on Operating Systems Principles}\n}</pre> 2023            Simplifying Cloud Management with Cloudless Computing                     Yiming Qiu, Patrick Tser Jern Kon, Jiarong Xing, Yibo Huang, Hongyi           Liu, Xinyu Wang, Peng Huang, Mosharaf Chowdhury, Ang Chen          Proceedings of the 22nd ACM Workshop on Hot Topics in Networks, 2023            [paper]          BibTeX <pre>\n@inproceedings{qiu2023simplifyingcloudmanagement,\n    author = {Qiu, Yiming and Kon, Patrick Tser Jern and Xing, Jiarong and Huang, Yibo and Liu, Hongyi and Wang, Xinyu and Huang, Peng and Chowdhury, Mosharaf and Chen, Ang},\n    title = {Simplifying Cloud Management with Cloudless Computing},\n    booktitle = {Proceedings of the 22nd ACM Workshop on Hot Topics in Networks},\n    year = {2023}\n}</pre>"}]}